   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  94               	.global	__vector_default
  96               	__vector_default:
   1:main.c        **** /*****************************************************************************
   2:main.c        **** *
   3:main.c        **** * AVRPROG compatible boot-loader
   4:main.c        **** * Version  : 0.85 (Dec. 2008)
   5:main.c        **** * Compiler : avr-gcc 4.1.2 / avr-libc 1.4.6
   6:main.c        **** * size     : depends on features and startup ( minmal features < 512 words)
   7:main.c        **** * by       : Martin Thomas, Kaiserslautern, Germany
   8:main.c        **** *            eversmith@heizung-thomas.de
   9:main.c        **** *            Additional code and improvements contributed by:
  10:main.c        **** *           - Uwe Bonnes
  11:main.c        **** *           - Bjoern Riemer
  12:main.c        **** *           - Olaf Rempel
  13:main.c        **** *
  14:main.c        **** * License  : Copyright (c) 2006-2008 M. Thomas, U. Bonnes, O. Rempel
  15:main.c        **** *            Free to use. You have to mention the copyright
  16:main.c        **** *            owners in source-code and documentation of derived
  17:main.c        **** *            work. No warranty! (Yes, you can insert the BSD
  18:main.c        **** *            license here)
  19:main.c        **** *
  20:main.c        **** * Tested with ATmega8, ATmega16, ATmega162, ATmega32, ATmega324P,
  21:main.c        **** *             ATmega644, ATmega644P, ATmega128, AT90CAN128
  22:main.c        **** *
  23:main.c        **** * - Initial versions have been based on the Butterfly bootloader-code
  24:main.c        **** *   by Atmel Corporation (Authors: BBrandal, PKastnes, ARodland, LHM)
  25:main.c        **** *
  26:main.c        **** ****************************************************************************
  27:main.c        **** *
  28:main.c        **** *  See the makefile and readme.txt for information on how to adapt 
  29:main.c        **** *  the linker-settings to the selected Boot Size (BOOTSIZE=xxxx) and 
  30:main.c        **** *  the MCU-type. Other configurations futher down in this file.
  31:main.c        **** *
  32:main.c        **** *  With BOOT_SIMPLE, minimal features and discarded int-vectors
  33:main.c        **** *  this bootloader has should fit into a a 512 word (1024, 0x400 bytes) 
  34:main.c        **** *  bootloader-section. 
  35:main.c        **** *
  36:main.c        **** ****************************************************************************/
  37:main.c        **** 
  38:main.c        **** /* Частота контроллера (кварца) */
  39:main.c        **** #ifndef F_CPU
  40:main.c        **** // #define F_CPU 7372800
  41:main.c        **** //#define F_CPU (7372800/2)
  42:main.c        **** //#define F_CPU 11059200UL
  43:main.c        **** #define F_CPU 16000000UL
  44:main.c        **** #endif
  45:main.c        **** 
  46:main.c        **** /* UART Скорость UART оптимально 19200 */
  47:main.c        **** //#define BAUDRATE 9600
  48:main.c        **** #define BAUDRATE 19200
  49:main.c        **** //#define BAUDRATE 115200
  50:main.c        **** 
  51:main.c        **** /* Режим двойной скорости UART (бит U2C)*/
  52:main.c        **** //#define UART_DOUBLESPEED
  53:main.c        **** 
  54:main.c        **** /* Используется второй UART на mega128 / can128 / mega162 / mega324p / mega644p */
  55:main.c        **** //#define UART_USE_SECOND
  56:main.c        **** 
  57:main.c        **** /* Тип устройства:
  58:main.c        ****    Для AVRProg выбирать BOOT 
  59:main.c        ****    Это корректное значение для bootloader.
  60:main.c        ****    avrdude может определить только part-code для ISP */
  61:main.c        **** #define DEVTYPE     DEVTYPE_BOOT
  62:main.c        **** //#define DEVTYPE     DEVTYPE_ISP
  63:main.c        **** 
  64:main.c        **** /*
  65:main.c        ****  * Выбор порта для кнопки входа в загрузчик
  66:main.c        ****  * Чтобы войти в загрузчик надо чтобы при запуске эта кнопка замыкала пин на землю
  67:main.c        ****  */
  68:main.c        **** #define BLPORT		PORTD
  69:main.c        **** #define BLDDR		DDRD
  70:main.c        **** #define BLPIN		PIND
  71:main.c        **** #define BLPNUM		PIND7
  72:main.c        **** 
  73:main.c        **** 
  74:main.c        **** /*
  75:main.c        ****  * Выбор порта для индикатора работы загрузчика
  76:main.c        ****  * Светодиод горит - мы в загрузчике
  77:main.c        ****  */
  78:main.c        **** 
  79:main.c        **** #define ENABLE_BOOT_LED
  80:main.c        **** #define BIPORT		PORTB
  81:main.c        **** #define BIDDR		DDRB
  82:main.c        **** #define BIPIN		PINB
  83:main.c        **** #define BIPNUM		PINB6
  84:main.c        **** #define BIPNUM2    PINB7
  85:main.c        **** 
  86:main.c        **** 
  87:main.c        **** /*
  88:main.c        ****  * Выключить Собачий таймер на время загрузчика
  89:main.c        ****  */
  90:main.c        **** #define DISABLE_WDT_AT_STARTUP
  91:main.c        **** 
  92:main.c        **** /*
  93:main.c        ****  * Watchdog-reset is issued at exit 
  94:main.c        ****  * define the timeout-value here (see avr-libc manual)
  95:main.c        ****  */
  96:main.c        **** #define EXIT_WDT_TIME   WDTO_250MS
  97:main.c        **** 
  98:main.c        **** /*
  99:main.c        ****  * Выбор режима загрузчика
 100:main.c        ****  * SIMPLE-Mode - Загрузчик стартует когда нажата его кнопка
 101:main.c        ****  *   переход к основной программе осуществляется после сброса 
 102:main.c        ****  *   (кнопка должна быть отжата) либо по команде от программатора
 103:main.c        ****  *   При этом режиме вывод на кнопку конфигурируется как вход-с подтягом,
 104:main.c        ****  *   но при выходе из загрузчика все выставляется по умолчанию
 105:main.c        ****  * POWERSAVE-Mode - Startup is separated in two loops
 106:main.c        ****  *   which makes power-saving a little easier if no firmware
 107:main.c        ****  *   is on the chip. Needs more memory
 108:main.c        ****  * BOOTICE-Mode - для зашивки  JTAGICE файла upgrade.ebn в Мегу16.
 109:main.c        ****  *   что превращает ее в JTAG отладчик. Разумеется нужно добавить весь необходимый
 110:main.c        ****  *   обвяз на кристалл для этого. И частота должна быть везде прописана как 7372800
 111:main.c        ****  *   в F_CPU Для совместимости с родной прошивкой JTAG ICE
 112:main.c        ****  * WAIT-mode Bootloader ожидает команды на вход, если ее не было в течении промежутка времени
 113:main.c        ****  *   (который настраивается) то проихсодит переход к основной программе.
 114:main.c        ****  */
 115:main.c        **** //#define START_SIMPLE
 116:main.c        **** #define START_WAIT
 117:main.c        **** //#define START_POWERSAVE
 118:main.c        **** //#define START_BOOTICE
 119:main.c        **** 
 120:main.c        **** /* Команда для входа в загрузчик в START_WAIT */
 121:main.c        **** #define START_WAIT_UARTCHAR 'S'
 122:main.c        **** 
 123:main.c        **** /* Выдержка для START_WAIT mode ( t = WAIT_TIME * 10ms ) */
 124:main.c        **** #define WAIT_VALUE 800 /* сейчас: 300*10ms = 3000ms = 3sec */
 125:main.c        **** 
 126:main.c        **** /*
 127:main.c        ****  * enable/disable readout of fuse and lock-bits
 128:main.c        ****  * (AVRPROG has to detect the AVR correctly by device-code
 129:main.c        ****  * to show the correct information).
 130:main.c        ****  */
 131:main.c        **** //#define ENABLEREADFUSELOCK
 132:main.c        **** 
 133:main.c        **** /* enable/disable write of lock-bits
 134:main.c        ****  * WARNING: lock-bits can not be reseted by bootloader (as far as I know)
 135:main.c        ****  * Only protection no unprotection, "chip erase" from bootloader only
 136:main.c        ****  * clears the flash but does no real "chip erase" (this is not possible
 137:main.c        ****  * with a bootloader as far as I know)
 138:main.c        ****  * Keep this undefined!
 139:main.c        ****  */
 140:main.c        **** //#define WRITELOCKBITS
 141:main.c        **** 
 142:main.c        **** /*
 143:main.c        ****  * define the following if the bootloader should not output
 144:main.c        ****  * itself at flash read (will fake an empty boot-section)
 145:main.c        ****  */
 146:main.c        **** //#define READ_PROTECT_BOOTLOADER 
 147:main.c        **** 
 148:main.c        **** #define VERSION_HIGH '0'
 149:main.c        **** #define VERSION_LOW  '8'
 150:main.c        **** 
 151:main.c        **** #define GET_LOCK_BITS           0x0001
 152:main.c        **** #define GET_LOW_FUSE_BITS       0x0000
 153:main.c        **** #define GET_HIGH_FUSE_BITS      0x0003
 154:main.c        **** #define GET_EXTENDED_FUSE_BITS  0x0002
 155:main.c        **** 
 156:main.c        **** /* Расчет делителя частоты для USART*/
 157:main.c        **** #ifdef UART_DOUBLESPEED
 158:main.c        **** 
 159:main.c        **** 	#define UART_CALC_BAUDRATE(baudRate) ((uint32_t)((F_CPU) + ((uint32_t)baudRate * 4UL)) / ((uint32_
 160:main.c        **** 
 161:main.c        **** #else
 162:main.c        **** 
 163:main.c        **** 	#define UART_CALC_BAUDRATE(baudRate) ((uint32_t)((F_CPU) + ((uint32_t)baudRate * 8UL)) / ((uint32_
 164:main.c        **** 
 165:main.c        **** #endif
 166:main.c        **** 
 167:main.c        **** 
 168:main.c        **** #include <stdint.h>
 169:main.c        **** #include <avr/io.h>
 170:main.c        **** #include <avr/wdt.h>
 171:main.c        **** #include <avr/boot.h>
 172:main.c        **** #include <avr/pgmspace.h>
 173:main.c        **** #include <avr/eeprom.h>
 174:main.c        **** #include <avr/interrupt.h>
 175:main.c        **** #include <util/delay.h>
 176:main.c        **** 
 177:main.c        **** #include "chipdef.h"
 178:main.c        **** 
 179:main.c        **** uint8_t gBuffer[SPM_PAGESIZE];
 180:main.c        **** 
 181:main.c        **** #if defined(BOOTLOADERHASNOVECTORS)
 182:main.c        **** 	#warning "This Bootloader does not link interrupt vectors - see makefile"
 183:main.c        **** 	/* make the linker happy - it wants to see __vector_default */
 184:main.c        **** 	// void __vector_default(void) { ; }
 185:main.c        **** 	void __vector_default(void) { ; }
  97               	abn	68,0,185,.LM0-.LFBB1
  98               	.LM0:
  99               	.LFBB1:
 100               	/* prologue: function */
 101               	/* frame size = 0 */
 102               	/* epilogue start */
 104               	.LM1:
 105 0000 0895      		ret
 107               	.Lscope1:
 110               	send_boot:
 186:main.c        **** _STATUS & (1<<UART_TXREADY)));
 187:main.c        **** 	UART_DATA = data;
 188:main.c        **** }
 189:main.c        **** 
 190:main.c        **** static uint8_t recvchar(void)
 191:main.c        **** {
 192:main.c        **** 	while (!(UART_STATUS & (1<<UART_RXREADY)));
 193:main.c        **** 	return UART_DATA;
 194:main.c        **** }
 195:main.c        **** 
 196:main.c        **** static inline void eraseFlash(void)
 197:main.c        **** {
 198:main.c        **** 	// erase only main section (bootloader protection)
 199:main.c        **** 	uint32_t addr = 0;
 200:main.c        **** 	while (APP_END > addr) 
 201:main.c        **** 		{
 202:main.c        **** 		boot_page_erase(addr);		// Perform page erase
 203:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 204:main.c        **** 		addr += SPM_PAGESIZE;
 205:main.c        **** 		}
 206:main.c        **** 	boot_rww_enable();
 207:main.c        **** }
 208:main.c        **** 
 209:main.c        **** static inline void recvBuffer(pagebuf_t size)
 210:main.c        **** {
 211:main.c        **** 	pagebuf_t cnt;
 212:main.c        **** 	uint8_t *tmp = gBuffer;
 213:main.c        **** 
 214:main.c        **** 	for (cnt = 0; cnt < sizeof(gBuffer); cnt++) 
 215:main.c        **** 		{
 216:main.c        **** 		*tmp++ = (cnt < size) ? recvchar() : 0xFF;
 217:main.c        **** 		}
 218:main.c        **** }
 219:main.c        **** 
 220:main.c        **** static inline uint16_t writeFlashPage(uint16_t waddr, pagebuf_t size)
 221:main.c        **** {
 222:main.c        **** 	uint32_t pagestart = (uint32_t)waddr<<1;
 223:main.c        **** 	uint32_t baddr = pagestart;
 224:main.c        **** 	uint16_t data;
 225:main.c        **** 	uint8_t *tmp = gBuffer;
 226:main.c        **** 
 227:main.c        **** 	do 
 228:main.c        **** 		{
 229:main.c        **** 		data = *tmp++;
 230:main.c        **** 		data |= *tmp++ << 8;
 231:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 232:main.c        **** 
 233:main.c        **** 		baddr += 2;			// Select next word in memory
 234:main.c        **** 		size -= 2;			// Reduce number of bytes to write by two
 235:main.c        **** 		} 
 236:main.c        **** 	while (size);				// Loop until all bytes written
 237:main.c        **** 
 238:main.c        **** 	boot_page_write(pagestart);
 239:main.c        **** 	boot_spm_busy_wait();
 240:main.c        **** 	boot_rww_enable();		// Re-enable the RWW section
 241:main.c        **** 
 242:main.c        **** 	return baddr>>1;
 243:main.c        **** }
 244:main.c        **** 
 245:main.c        **** static inline uint16_t writeEEpromPage(uint16_t address, pagebuf_t size)
 246:main.c        **** {
 247:main.c        **** 	uint8_t *tmp = gBuffer;
 248:main.c        **** 
 249:main.c        **** 	do 
 250:main.c        **** 		{
 251:main.c        **** 		eeprom_write_byte( (uint8_t*)address, *tmp++ );
 252:main.c        **** 		address++;			// Select next byte
 253:main.c        **** 		size--;				// Decreas number of bytes to write
 254:main.c        **** 		}
 255:main.c        **** 	while (size);				// Loop until all bytes written
 256:main.c        **** 
 257:main.c        **** 	// eeprom_busy_wait();
 258:main.c        **** 
 259:main.c        **** 	return address;
 260:main.c        **** }
 261:main.c        **** 
 262:main.c        **** static inline uint16_t readFlashPage(uint16_t waddr, pagebuf_t size)
 263:main.c        **** {
 264:main.c        **** 	uint32_t baddr = (uint32_t)waddr<<1;
 265:main.c        **** 	uint16_t data;
 266:main.c        **** 
 267:main.c        **** 	do 
 268:main.c        **** 	{
 269:main.c        **** 
 270:main.c        **** #ifndef READ_PROTECT_BOOTLOADER
 271:main.c        **** #warning "Bootloader not read-protected"
 272:main.c        **** 
 273:main.c        **** 	#if defined(RAMPZ)
 274:main.c        **** 		data = pgm_read_word_far(baddr);
 275:main.c        **** 	#else
 276:main.c        **** 		data = pgm_read_word_near(baddr);
 277:main.c        **** 	#endif
 278:main.c        **** 
 279:main.c        **** #else
 280:main.c        **** 		// don't read bootloader
 281:main.c        **** 		if ( baddr < APP_END ) 
 282:main.c        **** 		{
 283:main.c        **** 		#if defined(RAMPZ)
 284:main.c        **** 			data = pgm_read_word_far(baddr);
 285:main.c        **** 		#else
 286:main.c        **** 			data = pgm_read_word_near(baddr);
 287:main.c        **** 		#endif
 288:main.c        **** 		}
 289:main.c        **** 		else 
 290:main.c        **** 		{
 291:main.c        **** 		data = 0xFFFF; // fake empty
 292:main.c        **** 		}
 293:main.c        **** #endif
 294:main.c        **** 		sendchar(data);			// send LSB
 295:main.c        **** 		sendchar((data >> 8));		// send MSB
 296:main.c        **** 		baddr += 2;			// Select next word in memory
 297:main.c        **** 		size -= 2;			// Subtract two bytes from number of bytes to read
 298:main.c        **** 	} 
 299:main.c        **** 	while (size);				// Repeat until block has been read
 300:main.c        **** 	return baddr>>1;
 301:main.c        **** }
 302:main.c        **** 
 303:main.c        **** static inline uint16_t readEEpromPage(uint16_t address, pagebuf_t size)
 304:main.c        **** {
 305:main.c        **** 	do 
 306:main.c        **** 	{
 307:main.c        **** 	sendchar( eeprom_read_byte( (uint8_t*)address ) );
 308:main.c        **** 	address++;
 309:main.c        **** 	size--;				// Decrease number of bytes to read
 310:main.c        **** 	} 
 311:main.c        **** 	while (size);				// Repeat until block has been read
 312:main.c        **** 
 313:main.c        **** 	return address;
 314:main.c        **** }
 315:main.c        **** 
 316:main.c        **** #if defined(ENABLEREADFUSELOCK)
 317:main.c        **** static uint8_t read_fuse_lock(uint16_t addr)
 318:main.c        **** {
 319:main.c        **** 	uint8_t mode = (1<<BLBSET) | (1<<SPMEN);
 320:main.c        **** 	uint8_t retval;
 321:main.c        **** 
 322:main.c        **** 	asm volatile
 323:main.c        **** 	(
 324:main.c        **** 		"movw r30, %3\n\t"		/* Z to addr */ \
 325:main.c        **** 		"sts %0, %2\n\t"		/* set mode in SPM_REG */ \
 326:main.c        **** 		"lpm\n\t"			/* load fuse/lock value into r0 */ \
 327:main.c        **** 		"mov %1,r0\n\t"			/* save return value */ \
 328:main.c        **** 		: "=m" (SPM_REG),
 329:main.c        **** 		  "=r" (retval)
 330:main.c        **** 		: "r" (mode),
 331:main.c        **** 		  "r" (addr)
 332:main.c        **** 		: "r30", "r31", "r0"
 333:main.c        **** 	);
 334:main.c        **** 	return retval;
 335:main.c        **** }
 336:main.c        **** #endif
 337:main.c        **** 
 338:main.c        **** static void send_boot(void)
 339:main.c        **** {
 340:main.c        **** 	sendchar('A');
 341:main.c        **** 	sendchar('V');
 342:main.c        **** 	sendchar('R');
 343:main.c        **** 	sendchar('B');
 111               	43,.LM2-.LFBB2
 112               	.LM2:
 113               	.LFBB2:
 114               	/* prologue: function */
 115               	/* frame size = 0 */
 116               	.L4:
 117               	.LBB124:
 118               	.LBB125:
 120               	.LM3:
 121 0002 5D9B      		sbis 43-32,5
 122 0004 00C0      		rjmp .L4
 124               	.LM4:
 125 0006 81E4      		ldi r24,lo8(65)
 126 0008 8CB9      		out 44-32,r24
 127               	.L5:
 128               	.LBE125:
 129               	.LBE124:
 130               	.LBB126:
 131               	.LBB127:
 133               	.LM5:
 134 000a 5D9B      		sbis 43-32,5
 135 000c 00C0      		rjmp .L5
 137               	.LM6:
 138 000e 86E5      		ldi r24,lo8(86)
 139 0010 8CB9      		out 44-32,r24
 140               	.L6:
 141               	.LBE127:
 142               	.LBE126:
 143               	.LBB128:
 144               	.LBB129:
 146               	.LM7:
 147 0012 5D9B      		sbis 43-32,5
 148 0014 00C0      		rjmp .L6
 150               	.LM8:
 151 0016 82E5      		ldi r24,lo8(82)
 152 0018 8CB9      		out 44-32,r24
 153               	.L7:
 154               	.LBE129:
 155               	.LBE128:
 156               	.LBB130:
 157               	.LBB131:
 159               	.LM9:
 160 001a 5D9B      		sbis 43-32,5
 161 001c 00C0      		rjmp .L7
 163               	.LM10:
 164 001e 82E4      		ldi r24,lo8(66)
 165 0020 8CB9      		out 44-32,r24
 166               	.L8:
 167               	.LBE131:
 168               	.LBE130:
 169               	.LBB132:
 170               	.LBB133:
 172               	.LM11:
 173 0022 5D9B      		sbis 43-32,5
 174 0024 00C0      		rjmp .L8
 176               	.LM12:
 177 0026 8FE4      		ldi r24,lo8(79)
 178 0028 8CB9      		out 44-32,r24
 179               	.L9:
 180               	.LBE133:
 181               	.LBE132:
 182               	.LBB134:
 183               	.LBB135:
 185               	.LM13:
 186 002a 5D9B      		sbis 43-32,5
 187 002c 00C0      		rjmp .L9
 189               	.LM14:
 190 002e 8FE4      		ldi r24,lo8(79)
 191 0030 8CB9      		out 44-32,r24
 192               	.L10:
 193               	.LBE135:
 194               	.LBE134:
 195               	.LBB136:
 196               	.LBB137:
 198               	.LM15:
 199 0032 5D9B      		sbis 43-32,5
 200 0034 00C0      		rjmp .L10
 202               	.LM16:
 203 0036 84E5      		ldi r24,lo8(84)
 204 0038 8CB9      		out 44-32,r24
 205               	/* epilogue start */
 206               	.LBE137:
 207               	.LBE136:
 344:main.c        **** to_app();
 345:main.c        **** 	MCUCSR = 0;
 346:main.c        **** 	uint16_t address = 0;
 347:main.c        **** 	uint8_t device = 0, val;
 348:main.c        **** 
 349:main.c        **** 
 350:main.c        **** 
 351:main.c        **** #ifdef ENABLE_BOOT_LED	// LED ON
 208               	(0,1)",36,0,0,main
 209               	.global	main
 211               	main:
 213               	.LM18:
 214               	.LFBB3:
 215               		push r2
 216               		push r3
 352:main.c        **** PORT |= ((1<<BIPNUM)|(1<<BIPNUM2));	
 353:main.c        **** 	BIDDR  |= ((1<<BIPNUM)|(1<<BIPNUM2));
 354:main.c        **** #endif
 355:main.c        **** 
 356:main.c        **** 
 217               		push r5
 218               		push r6
 219               		push r7
 220 003c 2F92      		push r8
 221 003e 3F92      		push r9
 222 0040 4F92      		push r10
 223 0042 5F92      		push r11
 224 0044 6F92      		push r12
 225 0046 7F92      		push r13
 226 0048 8F92      		push r14
 227 004a 9F92      		push r15
 228 004c AF92      		push r16
 229 004e BF92      		push r17
 230 0050 CF92      		push r29
 231 0052 DF92      		push r28
 232 0054 EF92      		rcall .
 233 0056 FF92      		push __tmp_reg__
 234 0058 0F93      		in r28,__SP_L__
 235 005a 1F93      		in r29,__SP_H__
 236 005c DF93      	/* prologue: function */
 237 005e CF93      	/* frame size = 3 */
 239 0062 0F92      	.LM19:
 240 0064 CDB7      		in __tmp_reg__,84-32
 241 0066 DEB7      		sbrs __tmp_reg__,3
 242               		rjmp .L20
 243               		ldi r30,lo8(0)
 357:main.c        **** #ifdef DISABLE_WDT_AT_STARTUP
 244               	:
 246 0068 04B6      	.LM20:
 247 006a 03FE      		out 84-32,__zero_reg__
 249 006e E0E0      	.LM21:
 250 0070 F0E0      		in r24,56-32
 251 0072 0995      		ori r24,lo8(-64)
 252               		out 56-32,r24
 358:main.c        **** #ifdef WDT_OFF_SPECIAL
 253               	8,0,366,.LM22-.LFBB3
 254               	.LM22:
 255 0074 14BE      		in r24,55-32
 359:main.c        **** 	#warning "using target specific watchdog_off"
 360:main.c        **** 		bootloader_wdt_off();
 361:main.c        **** 	#else
 362:main.c        **** 		cli();
 363:main.c        **** 		wdt_reset();
 364:main.c        **** 		wdt_disable();
 365:main.c        **** 	#endif
 256               	i r24,lo8(-64)
 257               		out 55-32,r24
 259 0078 806C      	.LM23:
 260 007a 88BB      	/* #APP */
 366:main.c        **** 	
 261               	75 "main.c" 1
 262               		cli
 263 007c 87B3      	 ;  0 "" 2
 265 0080 87BB      	.LM24:
 367:main.c        **** ifdef START_POWERSAVE
 368:main.c        **** 	uint8_t OK = 1;
 369:main.c        **** #endif
 370:main.c        **** 
 371:main.c        **** 	BLDDR  &= ~(1<<BLPNUM);		// set as Input
 372:main.c        **** 	BLPORT |= (1<<BLPNUM);		// Enable pullup
 373:main.c        **** 
 374:main.c        **** 	// Set baud rate
 375:main.c        **** 	UART_BAUD_HIGH = (UART_CALC_BAUDRATE(BAUDRATE)>>8) & 0xFF;
 266               	76 "main.c" 1
 267               		wdr
 268               	 ;  0 "" 2
 270 0082 F894      	.LM25:
 271               	/* #NOAPP */
 376:main.c        **** D_LOW = (UART_CALC_BAUDRATE(BAUDRATE) & 0xFF);
 272               	25,lo8(24)
 273               	/* #APP */
 274               	 ;  377 "main.c" 1
 275 0084 A895      		in __tmp_reg__, __SREG__
 276               		cli
 377:main.c        **** #ifdef UART_DOUBLESPEED
 277               	33, r25
 278               		out 33, __zero_reg__
 279               		out __SREG__,__tmp_reg__
 280 0086 98E1      		
 281               	 ;  0 "" 2
 283 0088 0FB6      	.LM26:
 284 008a F894      	/* #NOAPP */
 285 008c 91BD      		cbi 49-32,7
 287 0090 0FBE      	.LM27:
 288               		sbi 50-32,7
 378:main.c        **** UART_STATUS = ( 1<<UART_DOUBLE );
 379:main.c        **** #endif
 380:main.c        **** 
 381:main.c        **** 	UART_CTRL = UART_CTRL_DATA;
 382:main.c        **** 	UART_CTRL2 = UART_CTRL2_DATA;
 383:main.c        **** 	
 384:main.c        **** #if defined(START_POWERSAVE)
 385:main.c        **** 	/*
 290               	44,__zero_reg__
 292               	.LM29:
 293 0092 8F98      		ldi r24,lo8(51)
 386:main.c        **** s an adoption of the Butterfly Bootloader startup-sequence.
 294               	 41-32,r24
 296 0094 979A      	.LM30:
 387:main.c        **** 	It may look a little strange but separating the login-loop from
 388:main.c        **** 		the main parser-loop gives a lot a possibilities (timeout, sleep-modes
 389:main.c        **** 	    etc.).
 297               	t 42-32,r25
 299 0096 1092 9000 	.LM31:
 390:main.c        **** 
 300               	i r24,lo8(6)
 301               		sts 149,r24
 302 009a 83E3      		clr r12
 303 009c 89B9      		clr r13
 391:main.c        **** 	for(;OK;) 
 392:main.c        **** 	{
 393:main.c        **** 		if ((BLPIN & (1<<BLPNUM))) 
 394:main.c        **** 		{
 395:main.c        **** 		// jump to main app if pin is not grounded
 396:main.c        **** 		BLPORT &= ~(1<<BLPNUM);	// set to default
 304               	abn	68,0,483,.LM32-.LFBB3
 305               	.LM32:
 306 009e 9AB9      		clr r14
 397:main.c        **** #ifdef UART_DOUBLESPEED
 307               	r r15
 308               	.LBB138:
 309 00a0 86E0      	.LBB139:
 310 00a2 8093 9500 	.LBB140:
 311 00a6 CC24      	.LBB141:
 398:main.c        **** 		UART_STATUS &= ~( 1<<UART_DOUBLE );
 399:main.c        **** 		#endif
 400:main.c        **** 
 401:main.c        **** 
 402:main.c        **** 		#ifdef ENABLE_BOOT_LED	// LED OFF
 403:main.c        **** 		BIPORT &= ~((1<<BIPNUM)|(1<<BIPNUM2));	
 404:main.c        **** 		BIDDR  &= ~((1<<BIPNUM)|(1<<BIPNUM2));
 405:main.c        **** 		#endif
 406:main.c        **** 
 407:main.c        **** 		jump_to_app();		// Jump to application sector
 408:main.c        **** 
 409:main.c        **** 		} 
 410:main.c        **** 		else 
 411:main.c        **** 		{
 412:main.c        **** 		val = recvchar();
 413:main.c        **** 		/* ESC */
 414:main.c        **** 			if (val == 0x1B) 
 415:main.c        **** 			{
 416:main.c        **** 				// AVRPROG connection
 417:main.c        **** 				// Wait for signon
 418:main.c        **** 				while (val != 'S')
 419:main.c        **** 				val = recvchar();
 420:main.c        **** 				
 421:main.c        **** 				send_boot();			// Report signon
 422:main.c        **** 				OK = 0;
 423:main.c        **** 			} 
 424:main.c        **** 			else 
 425:main.c        **** 			{
 426:main.c        **** 			sendchar('?');
 427:main.c        **** 			}
 428:main.c        **** 	    }
 429:main.c        **** 		// Power-Save code here
 430:main.c        **** 	}
 431:main.c        **** 
 432:main.c        **** #elif defined(START_SIMPLE)
 433:main.c        **** 
 434:main.c        **** 	if ((BLPIN & (1<<BLPNUM))) {
 435:main.c        **** 		// jump to main app if pin is not grounded
 436:main.c        **** 		BLPORT &= ~(1<<BLPNUM);		// set to default	
 437:main.c        **** 			
 438:main.c        **** 	#ifdef UART_DOUBLESPEED
 439:main.c        **** 		UART_STATUS &= ~( 1<<UART_DOUBLE );
 440:main.c        **** 	#endif
 441:main.c        **** 
 442:main.c        **** 		#ifdef ENABLE_BOOT_LED	// LED OFF
 443:main.c        **** 		BIPORT &= ~((1<<BIPNUM)|(1<<BIPNUM2));	
 444:main.c        **** 		BIDDR  &= ~((1<<BIPNUM)|(1<<BIPNUM2));
 445:main.c        **** 		#endif
 446:main.c        **** 
 447:main.c        **** 		jump_to_app();			// Jump to application sector
 448:main.c        **** 	}
 449:main.c        **** 
 450:main.c        **** #elif defined(START_WAIT)
 451:main.c        **** 
 452:main.c        **** 	uint16_t cnt = 0;
 453:main.c        **** 
 454:main.c        **** 	while (1) {
 455:main.c        **** 		if (UART_STATUS & (1<<UART_RXREADY))
 456:main.c        **** 			if (UART_DATA == START_WAIT_UARTCHAR)
 457:main.c        **** 				break;
 458:main.c        **** 
 459:main.c        **** 		if (cnt++ >= WAIT_VALUE) {
 460:main.c        **** 			BLPORT &= ~(1<<BLPNUM);		// set to default
 461:main.c        **** 
 462:main.c        **** 
 463:main.c        **** 			#ifdef ENABLE_BOOT_LED	// LED OFF
 464:main.c        **** 			BIPORT &= ~((1<<BIPNUM)|(1<<BIPNUM2));	
 465:main.c        **** 			BIDDR  &= ~((1<<BIPNUM)|(1<<BIPNUM2));
 466:main.c        **** 			#endif
 467:main.c        **** 			jump_to_app();			// Jump to application sector
 468:main.c        **** 		}
 469:main.c        **** 
 470:main.c        **** 		_delay_ms(10);
 471:main.c        **** 	}
 472:main.c        **** 	send_boot();
 473:main.c        **** 
 474:main.c        **** #elif defined(START_BOOTICE)
 475:main.c        **** #warning "BOOTICE mode - no startup-condition"
 476:main.c        **** 
 477:main.c        **** #else
 478:main.c        **** #error "Select START_ condition for bootloader in main.c"
 479:main.c        **** #endif
 480:main.c        **** 
 481:main.c        **** 
 482:main.c        **** 	for(;;) 
 483:main.c        **** 	{
 313               	1:
 315 00aa EE24      	.LM33:
 316 00ac FF24      		ldi r16,lo8(-25536)
 317               		ldi r17,hi8(-25536)
 318               	.L24:
 319               	.LBE141:
 320               	.LBE140:
 321               	.LBE139:
 322               	.LBE138:
   1:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
   5:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
   8:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  11:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****      distribution.
  15:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  16:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  20:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  32:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h,v 1.1 2007/05/13 21:23:20 joerg_wunsch Exp $ */
  33:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  34:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  37:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  39:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** /** \file */
  40:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  41:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     \code
  42:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  43:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     \endcode
  44:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  45:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  46:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  47:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  48:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  49:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  50:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  51:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  52:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  53:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  54:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  55:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  56:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  57:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  58:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     to the overall delay time.
  59:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  60:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  61:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  62:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** */
  63:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  64:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  65:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  66:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  67:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** #endif
  68:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  69:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  71:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     register.
  76:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  77:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     can be achieved.
  79:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** */
  80:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** void
  81:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** {
  83:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 	);
  89:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** }
  90:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  91:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  93:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     counter register pair.
  98:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 
  99:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h ****  */
 102:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** void
 103:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** {
 105:d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 323               	ain.c",132,0,0,.Ltext2
 324               	.Ltext2:
 326 00b0 1CE9      	.LM34:
 327               		sbis 43-32,7
 328               		rjmp .L21
 330               	.LM35:
 331               		in r24,44-32
 332               		cpi r24,lo8(83)
 333               		breq .L22
 334               	.L21:
 336 00b2 5F9B      	.LM36:
 337 00b4 00C0      		ldi r18,lo8(800)
 338               		cp r12,r18
 339               		ldi r18,hi8(800)
 340 00b6 8CB1      		cpc r13,r18
 341 00b8 8335      		brlo .L23
 343               	.LM37:
 344               		cbi 50-32,7
 346 00bc 20E2      	.LM38:
 347 00be C216      		in r24,56-32
 348 00c0 23E0      		andi r24,lo8(63)
 349 00c2 D206      		out 56-32,r24
 351               	.LM39:
 352               		in r24,55-32
 353 00c6 9798      		andi r24,lo8(63)
 354               		out 55-32,r24
 356 00c8 88B3      	.LM40:
 357 00ca 8F73      		movw r30,r14
 358 00cc 88BB      		icall
 359               	.L23:
 361 00ce 87B3      	.LM41:
 362 00d0 8F73      		sec
 363 00d2 87BB      		adc r12,__zero_reg__
 364               		adc r13,__zero_reg__
 365               	.LBB145:
 366 00d4 F701      	.LBB144:
 367 00d6 0995      	.LBB143:
 368               	.LBB142:
 370               	.Ltext3:
 372 00da C11C      	.LM42:
 373 00dc D11C      		movw r24,r16
 374               	/* #APP */
 375               	 ;  105 "d:/winavr-20100110/lib/gcc/../../avr/include/util/delay_basic.h" 1
 376               		1: sbiw r24,1
 377               		brne 1b
 378               	 ;  0 "" 2
 379               	/* #NOAPP */
 380               		rjmp .L24
 381               	.L22:
 382 00de C801      	.LBE142:
 383               	.LBE143:
 384               	.LBE144:
 385 00e0 0197      	.LBE145:
 387               	.Ltext4:
 389 00e4 00C0      	.LM43:
 390               		call send_boot
 391               		std Y+1,__zero_reg__
 392               		clr r10
 393               		clr r11
 394               	.L154:
 395               	.LBB146:
 396               	.LBB147:
 484:main.c        **** 
 485:main.c        **** 		{
 486:main.c        **** 			sendchar('Y');			// Autoincrement is quicker
 487:main.c        **** 
 488:main.c        **** 		//write address
 397               	0,197,.LM45-.LFBB3
 398               	.LM45:
 399 00e6 0E94 0000 		in r25,44-32
 400 00ea 1982      	.LBE147:
 401 00ec AA24      	.LBE146:
 403               	.LM46:
 404               		cpi r25,lo8(97)
 405               		brne .L26
 406               	.L92:
 407               	.LBB148:
 408 00f0 5F9B      	.LBB149:
 410               	.LM47:
 411               		sbis 43-32,5
 412 00f4 9CB1      		rjmp .L92
 414               	.LM48:
 489:main.c        **** {
 490:main.c        **** 		val = recvchar();
 491:main.c        **** 		// Autoincrement?
 492:main.c        **** 		if (val == 'a') 
 493:main.c        **** 		{
 494:main.c        **** 			sendchar('Y');			// Autoincrement is quicker
 495:main.c        **** 
 496:main.c        **** 		//write address
 497:main.c        **** 		} 
 498:main.c        **** 		else if (val == 'A') 
 499:main.c        **** 		{
 500:main.c        **** 			address = recvchar();		//read address 8 MSB
 501:main.c        **** 			address = (address<<8) | recvchar();
 502:main.c        **** 			sendchar('\r');
 415               	rjmp .L155
 416               	.L26:
 417 00f6 9136      	.LBE149:
 418 00f8 01F4      	.LBE148:
 420               	.LM49:
 421               		cpi r25,lo8(65)
 422               		brne .L28
 423               	.L93:
 424 00fa 5D9B      	.LBB150:
 425 00fc 00C0      	.LBB151:
 427               	.LM50:
 428 00fe 39E5      		sbis 43-32,7
 429 0100 00C0      		rjmp .L93
 431               	.LM51:
 432               		in r25,44-32
 503:main.c        ****  if (val == 'A') 
 504:main.c        **** 		{
 505:main.c        **** 			address = recvchar();		//read address 8 MSB
 506:main.c        **** 			address = (address<<8) | recvchar();
 507:main.c        **** 			sendchar('\r');
 508:main.c        **** 
 433               	E150:
 434               	.LBB152:
 435 0102 9134      	.LBB153:
 437               	.LM52:
 438               		sbis 43-32,7
 439               		rjmp .L30
 441               	.LM53:
 442 0106 5F9B      		in r24,44-32
 443 0108 00C0      	.L31:
 444               	.LBE153:
 445               	.LBE152:
 446 010a 9CB1      	.LBB154:
 447               	.LBB155:
 449               	.LM54:
 450               		sbis 43-32,5
 451               		rjmp .L31
 452               	.LBE155:
 453               	.LBE154:
 455 010e 00C0      	.LM55:
 456               		mov r3,r25
 457               		clr r2
 458 0110 8CB1      		mov r10,r24
 459               		clr r11
 460               		or r10,r2
 461               		or r11,r3
 462               		rjmp .L156
 463               	.L28:
 465               	.LM56:
 466 0112 5D9B      		cpi r25,lo8(98)
 467 0114 00C0      		brne .L32
 468               	.L94:
 469               	.LBB156:
 509:main.c        **** f (val == 'A') 
 510:main.c        **** 		{
 511:main.c        **** 			address = recvchar();		//read address 8 MSB
 470               	3
 471               	.LM57:
 472 0116 392E      		sbis 43-32,5
 473 0118 2224      		rjmp .L94
 475 011c BB24      	.LM58:
 476 011e A228      		ldi r24,lo8(89)
 477 0120 B328      		out 44-32,r24
 478 0122 00C0      	.L34:
 479               	.LBE157:
 512:main.c        **** 		// Autoincrement is quicker
 513:main.c        **** 
 514:main.c        **** 		//write address
 515:main.c        **** 		} 
 516:main.c        **** 		else if (val == 'A') 
 480               	LBB158:
 481               	.LBB159:
 483 0126 01F4      	.LM59:
 484               		sbis 43-32,5
 485               		rjmp .L34
 487               	.LM60:
 488               		ldi r25,lo8(1)
 489 0128 5D9B      		out 44-32,r25
 490 012a 00C0      	.L35:
 491               	.LBE159:
 492               	.LBE158:
 493 012c 89E5      	.LBB160:
 494 012e 8CB9      	.LBB161:
 496               	.LM61:
 497               		sbis 43-32,5
 498               		rjmp .L35
 499               		rjmp .L158
 500               	.L32:
 501               	.LBE161:
 502 0130 5D9B      	.LBE160:
 504               	.LM62:
 505               		cpi r25,lo8(66)
 506 0134 91E0      		breq .+2
 507 0136 9CB9      		rjmp .L36
 508               	.L98:
 509               	.LBB162:
 510               	.LBB163:
 511               	.LBB164:
 513               	.LM63:
 514               		sbis 43-32,7
 515 0138 5D9B      		rjmp .L98
 517 013c 00C0      	.LM64:
 518               		in r25,44-32
 519               	.L38:
 520               	.LBE164:
 517:main.c        **** increment?
 518:main.c        **** 		if (val == 'a') 
 519:main.c        **** 		{
 520:main.c        **** 			sendchar('Y');			// Autoincrement is quicker
 521:main.c        **** 
 522:main.c        **** 		//write address
 523:main.c        **** 		} 
 524:main.c        **** 		else if (val == 'A') 
 521               	96,.LM65-.LFBB3
 522               	.LM65:
 523 013e 9234      		sbis 43-32,7
 524 0140 01F0      		rjmp .L38
 526               	.LM66:
 527               		in r24,44-32
 528               	.LBE166:
 529               	.LBE165:
 531               	.LM67:
 532 0144 5F9B      		mov r5,r25
 533 0146 00C0      		clr r4
 535               	.LM68:
 536 0148 9CB1      		mov r12,r24
 537               		clr r13
 538               		or r12,r4
 539               		or r13,r5
 540               	.L39:
 541               	.LBB167:
 542               	.LBB168:
 544 014a 5F9B      	.LM69:
 545 014c 00C0      		sbis 43-32,7
 546               		rjmp .L39
 548 014e 8CB1      	.LM70:
 549               		in r19,44-32
 550               		ldi r24,lo8(0)
 525:main.c        **** increment?
 526:main.c        **** 		if (val == 'a') 
 527:main.c        **** 		{
 551               	Buffer)
 552               		ldi r31,hi8(gBuffer)
 553 0150 592E      	.L43:
 554 0152 4424      	.LBE168:
 528:main.c        **** lect START_ condition for bootloader in main.c"
 555               	167:
 556               	.LBB169:
 557 0154 C82E      	.LBB170:
 559 0158 C428      	.LM71:
 560 015a D528      		cp r24,r12
 561               		cpc r25,r13
 562               		brlo .L97
 563               		ldi r18,lo8(-1)
 564               		rjmp .L41
 565               	.L97:
 566 015c 5F9B      	.LBB171:
 567 015e 00C0      	.LBB172:
 569               	.LM72:
 570 0160 3CB1      		sbis 43-32,7
 571 0162 80E0      		rjmp .L97
 573 0166 E0E0      	.LM73:
 574 0168 F0E0      		in r18,44-32
 575               	.L41:
 576               	.LBE172:
 577               	.LBE171:
 579               	.LM74:
 580               		st Z,r18
 582 016a 8C15      	.LM75:
 583 016c 9D05      		adiw r24,1
 584 016e 00F0      		ldi r18,hi8(256)
 585 0170 2FEF      		cpi r24,lo8(256)
 586 0172 00C0      		cpc r25,r18
 587               		breq .L42
 589               	.LM76:
 590               		adiw r30,1
 591               		rjmp .L43
 592 0174 5F9B      	.L42:
 593 0176 00C0      	.LBE170:
 594               	.LBE169:
 596 0178 2CB1      	.LM77:
 597               		ldd r22,Y+1
 598               		cpi r22,lo8(70)
 599               		breq .+2
 600               		rjmp .L96
 602 017a 2083      	.LM78:
 603               		cpi r19,lo8(70)
 604               		breq .+2
 605 017c 0196      		rjmp .L45
 606 017e 21E0      	.LBB173:
 607 0180 8030      	.LBB174:
 609 0184 01F0      	.LM79:
 610               		movw r14,r10
 611               		ldi r16,lo8(0)
 612 0186 3196      		ldi r17,hi8(0)
 613 0188 00C0      		lsl r14
 614               		rol r15
 615               		rol r16
 616               		rol r17
 529:main.c        **** 
 530:main.c        **** #elif defined(START_BOOTICE)
 531:main.c        **** #warning "BOOTICE mode - no startup-condition"
 532:main.c        **** 
 617               	(gBuffer)
 618               	.L46:
 620 018c 6634      	.LM80:
 621 018e 01F0      		ld r24,X
 622 0190 00C0      		ldi r25,lo8(0)
 533:main.c        **** Jump to application sector
 534:main.c        **** 		}
 623               	n	68,0,234,.LM81-.LFBB3
 624               	.LM81:
 625 0192 3634      		adiw r26,1
 626 0194 01F0      		ld r9,X
 627 0196 00C0      		sbiw r26,1
 628               		clr r8
 629               		or r24,r8
 630               		or r25,r9
 632 0198 7501      	.LM82:
 633 019a 00E0      		adiw r26,2
 635 019e EE0C      	.LM83:
 636 01a0 FF1C      		ldi r22,lo8(1)
 637 01a2 001F      		movw r30,r18
 638 01a4 111F      	/* #APP */
 639 01a6 A801      	 ;  235 "main.c" 1
 640 01a8 9701      		movw  r0, r24
 641 01aa A0E0      		sts 104, r22
 642 01ac B0E0      		spm
 643               		clr  r1
 644               		
 645               	 ;  0 "" 2
 647 01b0 90E0      	.LM84:
 648               	/* #NOAPP */
 649               		subi r18,lo8(-(2))
 650 01b2 1196      		sbci r19,hi8(-(2))
 651 01b4 9C90      		sbci r20,hlo8(-(2))
 652 01b6 1197      		sbci r21,hhi8(-(2))
 654 01ba 8829      	.LM85:
 655 01bc 9929      		ldi r24,lo8(-2)
 656               		ldi r25,hi8(-2)
 657               		add r12,r24
 658 01be 1296      		adc r13,r25
 660               	.LM86:
 661 01c0 61E0      		cp r12,__zero_reg__
 662 01c2 F901      		cpc r13,__zero_reg__
 663               		brne .L46
 665 01c4 0C01      	.LM87:
 666 01c6 6093 6800 		ldi r22,lo8(5)
 667 01ca E895      		movw r30,r14
 668 01cc 1124      	/* #APP */
 669               	 ;  242 "main.c" 1
 670               		sts 104, r22
 671               		spm
 672               		
 673               	 ;  0 "" 2
 674 01ce 2E5F      	/* #NOAPP */
 675 01d0 3F4F      	.L47:
 677 01d4 5F4F      	.LM88:
 678               		lds r24,104
 679               	.LBE174:
 680 01d6 8EEF      		sbrc r24,0
 681 01d8 9FEF      		rjmp .L47
 682 01da C80E      	.LBB175:
 684               	.LM89:
 685               		ldi r24,lo8(17)
 686 01de C114      	/* #APP */
 687 01e0 D104      	 ;  244 "main.c" 1
 688 01e2 01F4      		sts 104, r24
 689               		spm
 690               		
 691 01e4 65E0      	 ;  0 "" 2
 693               	.LM90:
 694               	/* #NOAPP */
 695 01e8 6093 6800 		lsr r21
 696 01ec E895      		ror r20
 697               		ror r19
 698               		ror r18
 699               		movw r10,r18
 700               		rjmp .L95
 701               	.L45:
 702               	.LBE175:
 703 01ee 8091 6800 	.LBE173:
 705 01f2 80FD      	.LM91:
 706 01f4 00C0      		cpi r19,lo8(69)
 707               		brne .L95
 708               		std Y+3,r13
 709               		std Y+2,r12
 710 01f6 81E1      		movw r16,r10
 711               		ldi r20,lo8(gBuffer)
 712               		mov r14,r20
 713 01f8 8093 6800 		ldi r20,hi8(gBuffer)
 714 01fc E895      		mov r15,r20
 715               	.L49:
 716               	.LBB176:
 717               	.LBB177:
 719               	.LM92:
 720 01fe 5695      		movw r30,r14
 721 0200 4795      		ld r22,Z+
 722 0202 3795      		movw r14,r30
 723 0204 2795      		movw r24,r16
 724 0206 5901      		call __eewr_byte_m64
 726               	.LM93:
 727               		subi r16,lo8(-(1))
 728               		sbci r17,hi8(-(1))
 535:main.c        **** 
 536:main.c        **** 			BIPORT &= ~((1<<BIPNUM)|(1<<BIPNUM2));	
 537:main.c        **** 			BIDDR  &= ~((1<<BIPNUM)|(1<<BIPNUM2));
 538:main.c        **** 			#endif
 729               	std Y+3,r19
 730               		std Y+2,r18
 732 020c 01F4      	.LM95:
 733 020e DB82      		or r18,r19
 734 0210 CA82      		brne .L49
 735 0212 8501      		add r10,r12
 736 0214 40E0      		adc r11,r13
 737 0216 E42E      	.L95:
 738 0218 40E0      	.LBE177:
 739 021a F42E      	.LBE176:
 740               	.LBB178:
 741               	.LBB179:
 743               	.LM96:
 744               		sbis 43-32,5
 745 021c F701      		rjmp .L95
 746 021e 6191      	.L161:
 748 0222 C801      	.LM97:
 749 0224 0E94 0000 		ldi r19,lo8(13)
 750               	.L155:
 751               		out 44-32,r19
 752 0228 0F5F      		rjmp .L154
 753 022a 1F4F      	.L96:
 754               	.LBE179:
 755               	.LBE178:
 756 022c 2A81      	.LBB180:
 757 022e 3B81      	.LBB181:
 759 0232 3040      	.LM98:
 760 0234 3B83      		sbis 43-32,5
 761 0236 2A83      		rjmp .L96
 762               		rjmp .L158
 763               	.L36:
 764 0238 232B      	.LBE181:
 765 023a 01F4      	.LBE180:
 766 023c AC0C      	.LBE162:
 768               	.LM99:
 769               		cpi r25,lo8(103)
 770               		breq .+2
 771               		rjmp .L50
 772               	.L99:
 773               	.LBB182:
 774               	.LBB183:
 775 0240 5D9B      	.LBB184:
 777               	.LM100:
 778               		sbis 43-32,7
 779               		rjmp .L99
 781               	.LM101:
 782 0246 3CB9      		in r25,44-32
 783 0248 00C0      	.L52:
 784               	.LBE184:
 785               	.LBE183:
 786               	.LBB185:
 787               	.LBB186:
 789               	.LM102:
 790               		sbis 43-32,7
 791 024a 5D9B      		rjmp .L52
 793 024e 00C0      	.LM103:
 794               		in r24,44-32
 795               	.LBE186:
 796               	.LBE185:
 539:main.c        **** et to default
 540:main.c        **** 
 541:main.c        **** 
 542:main.c        **** 			#ifdef ENABLE_BOOT_LED	// LED OFF
 543:main.c        **** 			BIPORT &= ~((1<<BIPNUM)|(1<<BIPNUM2));	
 544:main.c        **** 			BIDDR  &= ~((1<<BIPNUM)|(1<<BIPNUM2));
 545:main.c        **** 			#endif
 546:main.c        **** 			jump_to_app();			// Jump to application sector
 547:main.c        **** 		}
 548:main.c        **** 
 549:main.c        **** 		_delay_ms(10);
 550:main.c        **** 	}
 551:main.c        **** 	send_boot();
 798               	ov r12,r24
 799               		clr r13
 800 0250 9736      		or r12,r6
 801 0252 01F0      		or r13,r7
 802 0254 00C0      	.L53:
 803               	.LBB187:
 804               	.LBB188:
 806               	.LM106:
 807               		sbis 43-32,7
 808               		rjmp .L53
 810 0258 00C0      	.LM107:
 811               		in r24,44-32
 812               	.LBE188:
 813 025a 9CB1      	.LBE187:
 815               	.LM108:
 816               		cpi r24,lo8(70)
 817               		brne .L54
 818               	.LBB189:
 819               	.LBB190:
 821 025c 5F9B      	.LM109:
 822 025e 00C0      		movw r24,r10
 823               		ldi r26,lo8(0)
 824               		ldi r27,hi8(0)
 825 0260 8CB1      		lsl r24
 826               		rol r25
 827               		rol r26
 552:main.c        **** ));	
 553:main.c        **** 			BIDDR  &= ~((1<<BIPNUM)|(1<<BIPNUM2));
 554:main.c        **** 			#endif
 828               	n	68,0,280,.LM110-.LFBB3
 829               	.LM110:
 830 0262 792E      		movw r30,r24
 831 0264 6624      	/* #APP */
 555:main.c        **** et to default
 832               	280 "main.c" 1
 833               		lpm r18, Z+
 834 0266 C82E      		lpm r19, Z
 835 0268 DD24      		
 836 026a C628      	 ;  0 "" 2
 837 026c D728      	/* #NOAPP */
 838               	.L55:
 839               	.LBE191:
 840               	.LBB192:
 841               	.LBB193:
 843 026e 5F9B      	.LM111:
 844 0270 00C0      		sbis 43-32,5
 845               		rjmp .L55
 847 0272 8CB1      	.LM112:
 848               		out 44-32,r18
 849               	.L56:
 556:main.c        **** ATUS & (1<<UART_RXREADY))
 557:main.c        **** 			if (UART_DATA == START_WAIT_UARTCHAR)
 558:main.c        **** 				break;
 850               	.LBB194:
 851               	.LBB195:
 853 0276 01F4      	.LM113:
 854               		sbis 43-32,5
 855               		rjmp .L56
 857               	.LM114:
 858 0278 C501      		out 44-32,r19
 859 027a A0E0      	.LBE195:
 860 027c B0E0      	.LBE194:
 862 0280 991F      	.LM115:
 863 0282 AA1F      		adiw r24,2
 864 0284 BB1F      		adc r26,__zero_reg__
 865               		adc r27,__zero_reg__
 867               	.LM116:
 868               		ldi r30,lo8(-2)
 869 0286 FC01      		ldi r31,hi8(-2)
 870               		add r12,r30
 871               		adc r13,r31
 873 028a 3491      	.LM117:
 874               		cp r12,__zero_reg__
 875               		cpc r13,__zero_reg__
 876               		brne .L57
 878               	.LM118:
 879               		lsr r27
 880               		ror r26
 881               		ror r25
 882               		ror r24
 883 028c 5D9B      		movw r10,r24
 884 028e 00C0      		rjmp .L154
 885               	.L54:
 886               	.LBE190:
 887 0290 2CB9      	.LBE189:
 889               	.LM119:
 890               		cpi r24,lo8(69)
 891               		breq .+2
 892               		rjmp .L154
 893               		movw r14,r12
 894               		movw r16,r10
 895 0292 5D9B      	.L59:
 896 0294 00C0      	.LBB196:
 898               	.LM120:
 899 0296 3CB9      		movw r24,r16
 900               		call __eerd_byte_m64
 901               	.L58:
 902               	.LBB197:
 903               	.LBB198:
 904 0298 0296      	.LBB199:
 906 029c B11D      	.LM121:
 907               		sbis 43-32,5
 908               		rjmp .L58
 910 02a0 FFEF      	.LM122:
 911 02a2 CE0E      		out 44-32,r24
 912 02a4 DF1E      	.LBE199:
 913               	.LBE198:
 915 02a6 C114      	.LM123:
 916 02a8 D104      		subi r16,lo8(-(1))
 917 02aa 01F4      		sbci r17,hi8(-(1))
 919               	.LM124:
 920 02ac B695      		sec
 921 02ae A795      		sbc r14,__zero_reg__
 922 02b0 9795      		sbc r15,__zero_reg__
 924 02b4 5C01      	.LM125:
 925 02b6 00C0      		cp r14,__zero_reg__
 926               		cpc r15,__zero_reg__
 927               		brne .L59
 928               		add r10,r12
 559:main.c        **** if (cnt++ >= WAIT_VALUE) {
 560:main.c        **** 			BLPORT &= ~(1<<BLPNUM);		// set to default
 561:main.c        **** 
 562:main.c        **** 
 929               	26-.LFBB3
 930               	.LM126:
 931 02b8 8534      		cpi r25,lo8(101)
 932 02ba 01F0      		brne .L60
 934 02be 7601      	.LM127:
 935 02c0 8501      		ldd r31,Y+1
 936               		cpi r31,lo8(70)
 937               		brne .L100
 938               		ldi r30,lo8(0)
 939               		ldi r31,hi8(0)
 940 02c2 C801      	.L63:
 941 02c4 0E94 0000 	.LBB200:
 942               	.LBB201:
 944               	.LM128:
 945               		ldi r18,lo8(3)
 946               	/* #APP */
 947               	 ;  206 "main.c" 1
 948 02c8 5D9B      		sts 104, r18
 949 02ca 00C0      		spm
 950               		
 951               	 ;  0 "" 2
 952 02cc 8CB9      	/* #NOAPP */
 953               	.L62:
 955               	.LM129:
 956               		lds r24,104
 957 02ce 0F5F      	.LBE201:
 958 02d0 1F4F      		sbrc r24,0
 959               		rjmp .L62
 960               		subi r30,lo8(-(256))
 961 02d2 0894      		sbci r31,hi8(-(256))
 962 02d4 E108      	.LBB202:
 964               	.LM130:
 965               		ldi r19,hi8(-2048)
 966 02d8 E114      		cpi r30,lo8(-2048)
 967 02da F104      		cpc r31,r19
 968 02dc 01F4      		brne .L63
 970 02e0 BD1C      	.LM131:
 971 02e2 00C0      		ldi r22,lo8(17)
 972               	/* #APP */
 973               	 ;  210 "main.c" 1
 974               		sts 104, r22
 975               		spm
 563:main.c        **** 		#ifdef ENABLE_BOOT_LED	// LED OFF
 564:main.c        **** 			BIPORT &= ~((1<<BIPNUM)|(1<<BIPNUM2));	
 565:main.c        **** 			BIDDR  &= ~((1<<BIPNUM)|(1<<BIPNUM2));
 566:main.c        **** 			#endif
 567:main.c        **** 			jump_to_app();			// Jump to application sector
 568:main.c        **** 		}
 569:main.c        **** 
 976               	00:
 977               	.LBB203:
 978 02e4 9536      	.LBB204:
 570:main.c        **** 		BIPORT &= ~((1<<BIPNUM)|(1<<BIPNUM2));	
 571:main.c        **** 			BIDDR  &= ~((1<<BIPNUM)|(1<<BIPNUM2));
 980               	32:
 981               		sbis 43-32,5
 982 02e8 F981      		rjmp .L100
 983 02ea F634      		rjmp .L162
 984 02ec 01F4      	.L60:
 985 02ee E0E0      	.LBE204:
 986 02f0 F0E0      	.LBE203:
 988               	.LM133:
 989               		cpi r25,lo8(69)
 990               		brne .L64
 992 02f2 23E0      	.LM134:
 993               		ldi r30,lo8(24)
 994               		ldi r31,hi8(24)
 995 02f4 2093 6800 		ldi r18,lo8(12)
 996 02f8 E895      	/* #APP */
 997               	 ;  581 "main.c" 1
 998               		in __tmp_reg__,__SREG__
 999               		cli
 1000               		wdr
 1001               		out 33,r30
 1002               		out __SREG__,__tmp_reg__
 1003 02fa 8091 6800 		out 33,r18
 1004               	 ;  0 "" 2
 1005 02fe 80FD      	/* #NOAPP */
 1006 0300 00C0      	.L65:
 1007 0302 E050      	.LBB205:
 1008 0304 FF4F      	.LBB206:
 1010               	.LM135:
 1011               		sbis 43-32,5
 1012 0306 38EF      		rjmp .L65
 1013 0308 E030      		rjmp .L161
 1014 030a F307      	.L64:
 1015 030c 01F4      	.LBE206:
 1016               	.LBE205:
 1018 030e 61E1      	.LM136:
 1019               		cpi r25,lo8(80)
 1020               		brne .L66
 1021 0310 6093 6800 	.L101:
 1022 0314 E895      	.LBB207:
 1023               	.LBB208:
 1025               	.LM137:
 1026               		sbis 43-32,5
 1027               		rjmp .L101
 1028               	.L156:
 1030               	.LM138:
 1031               		ldi r22,lo8(13)
 1032               		out 44-32,r22
 1033 0316 5D9B      		rjmp .L154
 1034 0318 00C0      	.L66:
 1035 031a 00C0      	.LBE208:
 1036               	.LBE207:
 1038               	.LM139:
 572:main.c        **** NUM);		// set to default
 573:main.c        **** 
 574:main.c        **** 
 575:main.c        **** 			#ifdef ENABLE_BOOT_LED	// LED OFF
 576:main.c        **** 			BIPORT &= ~((1<<BIPNUM)|(1<<BIPNUM2));	
 577:main.c        **** 			BIDDR  &= ~((1<<BIPNUM)|(1<<BIPNUM2));
 578:main.c        **** 			#endif
 579:main.c        **** 			jump_to_app();			// Jump to application sector
 1039               	n	68,0,190,.LM140-.LFBB3
 1040               	.LM140:
 1041 031c 9534      		sbis 43-32,5
 1042 031e 01F4      		rjmp .L102
 580:main.c        **** }
 581:main.c        **** 
 1043               	2:
 1045 0320 E8E1      	.LM141:
 1046 0322 F0E0      		ldi r24,lo8(13)
 1047 0324 2CE0      		rjmp .L160
 1048               	.L68:
 1049               	.LBE210:
 1050 0326 0FB6      	.LBE209:
 1052 032a A895      	.LM142:
 1053 032c E1BD      		cpi r25,lo8(112)
 1054 032e 0FBE      		brne .L70
 1055 0330 21BD      	.L103:
 1056               	.LBB211:
 1057               	.LBB212:
 1059               	.LM143:
 1060               		sbis 43-32,5
 1061               		rjmp .L103
 1063 0332 5D9B      	.LM144:
 1064 0334 00C0      		ldi r25,lo8(83)
 1065 0336 00C0      		out 44-32,r25
 1066               		rjmp .L154
 1067               	.L70:
 1068               	.LBE212:
 582:main.c        **** 		BIPORT &= ~((1<<BIPNUM)|(1<<BIPNUM2));	
 583:main.c        **** 			BIDDR  &= ~((1<<BIPNUM)|(1<<BIPNUM2));
 584:main.c        **** 			#endif
 585:main.c        **** 			jump_to_app();			// Jump to application sector
 586:main.c        **** 		}
 587:main.c        **** 
 588:main.c        **** 		_delay_ms(10);
 589:main.c        **** 	}
 590:main.c        **** 	send_boot();
 591:main.c        **** 
 592:main.c        **** #elif defined(START_BOOTICE)
 593:main.c        **** #warning "BOOTICE mode - no startup-condition"
 594:main.c        **** 
 595:main.c        **** #else
 596:main.c        **** #error "Select START_ condition for bootloader in main.c"
 597:main.c        **** #endif
 598:main.c        **** 
 599:main.c        **** 
 600:main.c        **** 	for(;;) 
 601:main.c        **** 	{
 1069               	.LM145-.LFBB3
 1070               	.LM145:
 1071 0338 9035      		cpi r25,lo8(116)
 1072 033a 01F4      		brne .L72
 1073               	.L104:
 1074               	.LBB213:
 1075               	.LBB214:
 1077               	.LM146:
 1078 033c 5D9B      		sbis 43-32,5
 1079 033e 00C0      		rjmp .L104
 1081               	.LM147:
 1082               		ldi r30,lo8(70)
 1083 0340 6DE0      		out 44-32,r30
 1084 0342 6CB9      	.L74:
 1085 0344 00C0      	.LBE214:
 1086               	.LBE213:
 1087               	.LBB215:
 1088               	.LBB216:
 602:main.c        **** E)
 603:main.c        **** #warning "BOOTICE mode - no startup-condition"
 604:main.c        **** 
 605:main.c        **** #else
 606:main.c        **** #error "Select START_ condition for bootloader in main.c"
 607:main.c        **** #endif
 1089               	o8(116)
 1090               		brne .L72
 1091 0346 9C34      	.L104:
 1092 0348 01F4      	.LBB213:
 1093               	.LBB214:
 1095               	.LM146:
 1096               		sbis 43-32,5
 1097               		rjmp .L104
 1099 034c 00C0      	.LM147:
 1100               		ldi r30,lo8(70)
 1101               		out 44-32,r30
 1102               	.L74:
 1103 034e 8DE0      	.LBE214:
 1104 0350 00C0      	.LBE213:
 1105               	.LBB215:
 1106               	.LBB216:
 608:main.c        **** efined(START_BOOTICE)
 609:main.c        **** #warning "BOOTICE mode - no startup-condition"
 610:main.c        **** 
 611:main.c        **** #else
 612:main.c        **** #error "Select START_ condition for bootloader in main.c"
 1108               	3:
 1109               	.LBB214:
 1111 0354 01F4      	.LM146:
 1112               		sbis 43-32,5
 1113               		rjmp .L104
 1115               	.LM147:
 1116               		ldi r30,lo8(70)
 1117 0356 5D9B      		out 44-32,r30
 1118 0358 00C0      	.L74:
 1119               	.LBE214:
 1120               	.LBE213:
 1121 035a 93E5      	.LBB215:
 1122 035c 9CB9      	.LBB216:
 1124               	.LM148:
 1125               		sbis 43-32,5
 1126               		rjmp .L74
 613:main.c        **** 
 614:main.c        **** #elif defined(START_BOOTICE)
 615:main.c        **** #warning "BOOTICE mode - no startup-condition"
 616:main.c        **** 
 617:main.c        **** #else
 618:main.c        **** #error "Select START_ condition for bootloader in main.c"
 619:main.c        **** #endif
 620:main.c        **** 
 621:main.c        **** 
 622:main.c        **** 	for(;;) 
 623:main.c        **** 	{
 624:main.c        **** 		val = recvchar();
 625:main.c        **** 		// Autoincrement?
 626:main.c        **** 		if (val == 'a') 
 627:main.c        **** 		{
 628:main.c        **** 			sendchar('Y');			// Autoincrement is quicker
 629:main.c        **** 
 630:main.c        **** 		//write address
 631:main.c        **** 		} 
 632:main.c        **** 		else if (val == 'A') 
 633:main.c        **** 		{
 634:main.c        **** 			address = recvchar();		//read address 8 MSB
 635:main.c        **** 			address = (address<<8) | recvchar();
 636:main.c        **** 			sendchar('\r');
 637:main.c        **** 
 638:main.c        **** 		// Buffer load support
 639:main.c        **** 		} 
 640:main.c        **** 		else if (val == 'b') 
 641:main.c        **** 		{
 642:main.c        **** 			sendchar('Y');					// Report buffer load supported
 643:main.c        **** 			sendchar((sizeof(gBuffer) >> 8) & 0xFF);	// Report buffer size in bytes
 644:main.c        **** 			sendchar(sizeof(gBuffer) & 0xFF);
 1127               	.LFBB3
 1128               	.LM146:
 1129 0360 9437      		sbis 43-32,5
 1130 0362 01F4      		rjmp .L104
 1132               	.LM147:
 1133               		ldi r30,lo8(70)
 1134               		out 44-32,r30
 1135               	.L74:
 1136 0364 5D9B      	.LBE214:
 1137 0366 00C0      	.LBE213:
 1138               	.LBB215:
 1139               	.LBB216:
 1141 036a ECB9      	.LM148:
 1142               		sbis 43-32,5
 1143               		rjmp .L74
 1144               	.L158:
 1146               	.LM149:
 1147               		out 44-32,__zero_reg__
 1148               		rjmp .L154
 1149 036c 5D9B      	.L72:
 1150 036e 00C0      	.LBE216:
 1151               	.LBE215:
 1153               	.LM150:
 1154 0370 1CB8      		mov r24,r25
 1155 0372 00C0      		subi r24,lo8(-(-120))
 1156               		cpi r24,lo8(2)
 1157               		brsh .L75
 1158               	.L105:
 645:main.c        ****  supported
 646:main.c        **** 			sendchar((sizeof(gBuffer) >> 8) & 0xFF);	// Report buffer size in bytes
 647:main.c        **** 			sendchar(sizeof(gBuffer) & 0xFF);
 648:main.c        **** 
 649:main.c        **** 		// Start buffer load
 650:main.c        **** 		} 
 1159               	bn	68,0,191,.LM149-.LFBB3
 1160               	.LM149:
 1161 0374 892F      		out 44-32,__zero_reg__
 1162 0376 8857      		rjmp .L154
 1163 0378 8230      	.L72:
 1164 037a 00F4      	.LBE216:
 1165               	.LBE215:
 1167               	.LM150:
 1168               		mov r24,r25
 1169               		subi r24,lo8(-(-120))
 1170 037c 5F9B      		cpi r24,lo8(2)
 1171 037e 00C0      		brsh .L75
 1172               	.L105:
 1173               	.LBB217:
 1174 0380 8CB1      	.LBB218:
 1176               	.LM151:
 1177               		sbis 43-32,7
 1178               		rjmp .L105
 1180               	.LM152:
 1181               		in r24,44-32
 1182 0382 5D9B      	.L77:
 1183 0384 00C0      	.LBE218:
 1184               	.LBE217:
 1185               	.LBB219:
 1186 0386 FDE0      	.LBB220:
 1188               	.LM153:
 1189               		sbis 43-32,5
 1190               		rjmp .L77
 651:main.c        **** Buffer) >> 8) & 0xFF);	// Report buffer size in bytes
 652:main.c        **** 			sendchar(sizeof(gBuffer) & 0xFF);
 653:main.c        **** 
 654:main.c        **** 		// Start buffer load
 655:main.c        **** 		} 
 656:main.c        **** 		else if (val == 'B') 
 657:main.c        **** 		{
 1191               		sbis 43-32,7
 1192               		rjmp .L105
 1194 038c 01F4      	.LM152:
 1195               		in r24,44-32
 1196               	.L77:
 1197               	.LBE218:
 1198               	.LBE217:
 1199               	.LBB219:
 1200 038e 5F9B      	.LBB220:
 1202               	.LM153:
 1203               		sbis 43-32,5
 1204 0392 2CB1      		rjmp .L77
 1206               	.LM154:
 1207               		ldi r31,lo8(13)
 1208               		rjmp .L159
 1209               	.L75:
 1210               	.LBE220:
 1211               	.LBE219:
 1213 0396 5D9B      	.LM155:
 1214 0398 00C0      		cpi r25,lo8(84)
 1215 039a 00C0      		brne .L78
 1216               	.L106:
 1217               	.LBB221:
 1218               	.LBB222:
 658:main.c        **** rt buffer size in bytes
 659:main.c        **** 			sendchar(sizeof(gBuffer) & 0xFF);
 660:main.c        **** 
 661:main.c        **** 		// Start buffer load
 662:main.c        **** 		} 
 663:main.c        **** 		else if (val == 'B') 
 1219               	191,.LM154-.LFBB3
 1220               	.LM154:
 1221 039c 9335      		ldi r31,lo8(13)
 1222 039e 01F4      		rjmp .L159
 664:main.c        ****  Report buffer size in bytes
 665:main.c        **** 			sendchar(sizeof(gBuffer) & 0xFF);
 1223               	,44-32
 1224               	.L77:
 1225 03a0 0E94 0000 	.LBE218:
 1226 03a4 00C0      	.LBE217:
 1227               	.LBB219:
 666:main.c        ****  supported
 667:main.c        **** 			sendchar((sizeof(gBuffer) >> 8) & 0xFF);	// Report buffer size in bytes
 668:main.c        **** 			sendchar(sizeof(gBuffer) & 0xFF);
 669:main.c        **** 
 1228               	2)
 1229               		brsh .L75
 1230 03a6 9635      	.L105:
 1231 03a8 01F4      	.LBB217:
 1232               	.LBB218:
 1234               	.LM151:
 1235               		sbis 43-32,7
 1236               		rjmp .L105
 1238 03ac 00C0      	.LM152:
 1239               		in r24,44-32
 1240               	.L77:
 1241 03ae 60E3      	.LBE218:
 1242 03b0 6CB9      	.LBE217:
 1243               	.LBB219:
 1244               	.LBB220:
 1246               	.LM153:
 1247               		sbis 43-32,5
 1248               		rjmp .L77
 1250 03b2 5D9B      	.LM154:
 1251 03b4 00C0      		ldi r31,lo8(13)
 1252               		rjmp .L159
 1253               	.L75:
 1254 03b6 88E3      	.LBE220:
 1255               	.LBE219:
 1257 03ba 00C0      	.LM155:
 1258               		cpi r25,lo8(84)
 1259               		brne .L78
 1260               	.L106:
 670:main.c        **** upported
 671:main.c        **** 			sendchar((sizeof(gBuffer) >> 8) & 0xFF);	// Report buffer size in bytes
 672:main.c        **** 			sendchar(sizeof(gBuffer) & 0xFF);
 673:main.c        **** 
 674:main.c        **** 		// Start buffer load
 675:main.c        **** 		} 
 676:main.c        **** 		else if (val == 'B') 
 677:main.c        **** 		{
 1261               	p .L77
 1263 03bc 9337      	.LM154:
 1264 03be 01F4      		ldi r31,lo8(13)
 1265               		rjmp .L159
 1266               	.L75:
 1267               	.LBE220:
 1268               	.LBE219:
 1270 03c0 5D9B      	.LM155:
 1271 03c2 00C0      		cpi r25,lo8(84)
 1272               		brne .L78
 1273               	.L106:
 1274 03c4 92E0      	.LBB221:
 1275 03c6 9CB9      	.LBB222:
 1277               	.LM156:
 1278               		sbis 43-32,7
 1279               		rjmp .L106
 1281               	.LM157:
 1282               		in r18,44-32
 1283 03c8 5D9B      		std Y+1,r18
 1284 03ca 00C0      	.L80:
 1285               	.LBE222:
 1286               	.LBE221:
 1287 03cc E6E9      	.LBB223:
 1288 03ce ECB9      	.LBB224:
 1290               	.LM158:
 1291               		sbis 43-32,5
 1292               		rjmp .L80
 1293               		rjmp .L161
 1294               	.L78:
 1295               	.LBE224:
 1296 03d0 5D9B      	.LBE223:
 1298               	.LM159:
 1299               		cpi r25,lo8(83)
 1300 03d4 FEE1      		brne .L81
 1302 03d6 FCB9      	.LM160:
 1303 03d8 00C0      		call send_boot
 1304               		rjmp .L154
 1305               	.L81:
 678:main.c        **** rt buffer size in bytes
 679:main.c        **** 			sendchar(sizeof(gBuffer) & 0xFF);
 680:main.c        **** 
 681:main.c        **** 		// Start buffer load
 682:main.c        **** 		} 
 683:main.c        **** 		else if (val == 'B') 
 684:main.c        **** 		{
 685:main.c        **** 			pagebuf_t size;
 1307               	.LM159:
 1308               		cpi r25,lo8(83)
 1309 03da 9B31      		brne .L81
 1311 03de 00C0      	.LM160:
 1312               		call send_boot
 1313               		rjmp .L154
 1314               	.L81:
 1316               	.LM161:
 1317 03e0 5D9B      		cpi r25,lo8(86)
 1318 03e2 00C0      		brne .L82
 1319               	.L107:
 1320               	.LBB225:
 1321 03e4 2FE3      	.LBB226:
 1323 03e8 00C0      	.LM162:
 1324               		sbis 43-32,5
 1325               		rjmp .L107
 1327               	.LM163:
 1328               		ldi r22,lo8(48)
 1329               		out 44-32,r22
 1330               	.L84:
 1331               	.LBE226:
 1332               	.LBE225:
 1333               	.LBB227:
 1334               	.LBB228:
 1336               	.LM164:
 1337               		sbis 43-32,5
 1338               		rjmp .L84
 1340               	.LM165:
 1341               		ldi r24,lo8(56)
 1342               	.L160:
 1343               		out 44-32,r24
 1344               		rjmp .L154
 1345               	.L82:
 1346               	.LBE228:
 1347               	.LBE227:
 1349               	.LM166:
 1350               		cpi r25,lo8(115)
 1351               		brne .L85
 1352               	.L108:
 1353               	.LBB229:
 1354               	.LBB230:
 1356               	.LM167:
 1357               		sbis 43-32,5
 1358               		rjmp .L108
 1360               	.LM168:
 1361               		ldi r25,lo8(2)
 1362               		out 44-32,r25
 1363               	.L87:
 1364               	.LBE230:
 1365               	.LBE229:
 1366               	.LBB231:
 1367               	.LBB232:
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Tronix\AppData\Local\Temp/ccFFQCvc.s:2      *ABS*:0000003f __SREG__
C:\Users\Tronix\AppData\Local\Temp/ccFFQCvc.s:3      *ABS*:0000003e __SP_H__
C:\Users\Tronix\AppData\Local\Temp/ccFFQCvc.s:4      *ABS*:0000003d __SP_L__
C:\Users\Tronix\AppData\Local\Temp/ccFFQCvc.s:5      *ABS*:00000034 __CCP__
C:\Users\Tronix\AppData\Local\Temp/ccFFQCvc.s:6      *ABS*:00000000 __tmp_reg__
C:\Users\Tronix\AppData\Local\Temp/ccFFQCvc.s:7      *ABS*:00000001 __zero_reg__
C:\Users\Tronix\AppData\Local\Temp/ccFFQCvc.s:96     .text:00000000 __vector_default
C:\Users\Tronix\AppData\Local\Temp/ccFFQCvc.s:110    .text:00000002 send_boot
C:\Users\Tronix\AppData\Local\Temp/ccFFQCvc.s:216    .text:0000003c main
                            *COM*:00000100 gBuffer

UNDEFINED SYMBOLS
__eewr_byte_m64
__eerd_byte_m64
__do_clear_bss
